'use strict';

const topics = require.main.require('./src/topics');
const db = require.main.require('./src/database');
const SocketPlugins = require.main.require('./src/socket.io/plugins');

const plugin = module.exports;

plugin.init = async function (params) {
    const { router } = params;
    const routeHelpers = require.main.require('./src/routes/helpers');

    // Setup routes for resolved/unsolved topics
    routeHelpers.setupPageRoute(router, '/unsolved', [], renderUnsolved);
    routeHelpers.setupPageRoute(router, '/solved', [], renderSolved);

    handleSocketIO();
};

plugin.appendConfig = async function (config) {
    config['question-and-answer'] = plugin._settings;
    return config;
};

// Add navigation for unsolved/solved topics
plugin.addNavigation = async function (menu) {
    console.log('running addNavigation');
    menu = menu.concat([
        {
            route: '/unsolved',
            title: 'Unsolved Topics',
            iconClass: 'fa-question-circle',
            textClass: 'visible-xs-inline',
            text: 'Unsolved Topics',
        },
        {
            route: '/solved',
            title: 'Solved Topics',
            iconClass: 'fa-check-circle',
            textClass: 'visible-xs-inline',
            text: 'Solved Topics',
        },
    ]);
    return menu;
};

// Function to render the unsolved page
async function renderUnsolved(req, res) {
    console.log('running renderUnsolved');
    res.render('recent', { title: 'Unsolved Topics' });
}

// Function to render the solved page
async function renderSolved(req, res) {
    console.log('running renderSolved');
    res.render('recent', { title: 'Solved Topics' });
}

// Automatically mark the topic as "unsolved" when created
plugin.actionTopicSave = async function (hookData) {
    console.log('running actionTopicSave');
    await db.sortedSetAdd('topics:unsolved', Date.now(), hookData.topic.tid);
    await topics.setTopicFields(hookData.topic.tid, { isSolved: 0 }); // Set as unsolved initially
};

// Add thread tools to toggle between solved/unsolved
plugin.addThreadTool = async function (hookData) {
    console.log('running addThreadTool');
    const isSolved = parseInt(hookData.topic.isSolved, 10);

    hookData.tools.push({
        class: `toggleSolved ${isSolved ? 'topic-solved' : 'topic-unsolved'}`,
        title: isSolved ? 'Mark Unsolved' : 'Mark Solved',
        icon: isSolved ? 'fa-question-circle' : 'fa-check-circle',
    });

    return hookData;
};

// Socket.IO for real-time actions
function handleSocketIO() {
    console.log('running handleSocketIO');
    SocketPlugins.ResolvedStatus = {};

    // Toggle the resolved status of a topic
    SocketPlugins.ResolvedStatus.toggleSolved = async function (socket, data) {
        const result = await toggleResolvedStatus(socket.uid, data.tid);
        return result;
    };
}

// Toggle the resolved status of a topic
async function toggleResolvedStatus(uid, tid) {
    console.log('running toggleResolvedStatus');
    let isSolved = await topics.getTopicField(tid, 'isSolved');
    isSolved = parseInt(isSolved, 10) === 1;
    return await markResolved(uid, tid, !isSolved);
}

// Mark or unmark a topic as resolved
async function markResolved(uid, tid, isSolved) {
    console.log('running markResolved');
    const updatedFields = { isSolved: isSolved ? 1 : 0 };
    await topics.setTopicFields(tid, updatedFields);

    if (isSolved) {
        await db.sortedSetAdd('topics:solved', Date.now(), tid);
        await db.sortedSetRemove('topics:unsolved', tid);
    } else {
        await db.sortedSetAdd('topics:unsolved', Date.now(), tid);
        await db.sortedSetRemove('topics:solved', tid);
    }

    return { isSolved: isSolved };
}

// Clean up when topic is deleted
plugin.actionTopicPurge = async function (hookData) {
    console.log('running actionTopicPurge');
    if (hookData.topic) {
        await db.sortedSetsRemove(['topics:solved', 'topics:unsolved'], hookData.topic.tid);
    }
};

// Get topics for the unsolved or solved pages
async function getTopics(type, page, cids, uid, settings) {
    console.log('running getTopics');
    const set = `topics:${type}`;
    let tids = await db.getSortedSetRevRange(set, 0, 199);
    tids = await topics.filterTidsByPrivileges(tids, uid);

    const start = Math.max(0, (page - 1) * settings.topicsPerPage);
    const stop = start + settings.topicsPerPage - 1;

    const topicCount = tids.length;
    tids = tids.slice(start, stop + 1);

    const topicsData = await topics.getTopicsByTids(tids, uid);
    return { topicCount, topics: topicsData };
}